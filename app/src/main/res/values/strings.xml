<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">My Leet Code Solutions</string>

    <!--Add Two Numbers-->
    <string name="add_two_numbers_code">
<![CDATA[
<!DOCTYPE html>
<p>&#160; &#160; fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {</p>
<p>&#160; &#160; &#160; &#160; if (l1 == null &amp;&amp; l2 == null)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; return null</p>
<p>&#160; &#160; &#160; &#160; var sum = 0</p>
<p>&#160; &#160; &#160; &#160; l1?.let { sum += l1.`val` }</p>
<p>&#160; &#160; &#160; &#160; l2?.let { sum += l2.`val` }</p>
<p>&#160; &#160; &#160; &#160; val result = ListNode(sum % 10)</p>
<p>&#160; &#160; &#160; &#160; result.next = addTwoNumbers(l1?.next, l2?.next)</p>
<p>&#160; &#160; &#160; &#160; if (sum / 10 &gt;= 1)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; result.next = addTwoNumbers(result.next, ListNode(1))</p>
<p>&#160; &#160; &#160; &#160; return result</p>
<p>&#160; &#160; }</p>
]]>
    </string>
    <string name="add_two_numbers_description">You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
    You may assume the two numbers do not contain any leading zero, except the number 0 itself.</string>

    <!--Common-->
    <string name="common_input_x">Input:\n%s</string>
    <string name="common_l1_x">l1 = %s</string>
    <string name="common_l2_x">l2 = %s</string>
    <string name="common_num_rows_x">numRows = %s</string>
    <string name="common_numbers_x">numbers = %s</string>
    <string name="common_numbers1_x" tools:ignore="Typos">numbers1 = %s</string>
    <string name="common_numbers2_x">numbers2 = %s</string>
    <string name="common_output_x">Output:\n%s</string>
    <string name="common_run">Run</string>
    <string name="common_s_x">s = %s</string>
    <string name="common_target_x">target = %s</string>
    <string name="common_x_x">x = %s</string>

    <!--Longest Palindromic Substring-->
    <string name="longest_palindromic_substring_code">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun longestPalindrome(s: String): String {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val fillChar = &apos;_&apos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val filledStr = StringBuilder(s.length * 2 + 1).apply {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (i in s.indices)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; append(fillChar).append(s[i])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; append(fillChar)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val radiusArray = Array(filledStr.length) { 0 }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var center = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var maxCenter = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var maxRadius = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var radius = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; while (center &lt; filledStr.length) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var nextRadius = radius + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (center - nextRadius &gt;= 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; center + nextRadius &lt; filledStr.length</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; filledStr[center + nextRadius] == filledStr[center - nextRadius]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radius = nextRadius</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextRadius++</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radiusArray[center] = radius</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (radiusArray[center] &gt; maxRadius) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxCenter = center</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxRadius = radiusArray[center]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val middleCenter = center</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val rightBound = center + radius</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; center++</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radius = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (center &lt;= rightBound) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val leftCenter = middleCenter - (center - middleCenter)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val reach = center + radiusArray[leftCenter]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (reach &lt; rightBound)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radiusArray[center] = radiusArray[leftCenter]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (reach &gt; rightBound)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radiusArray[center] = rightBound - center</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; radius = rightBound - center</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; center++</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return filledStr.substring(maxCenter - maxRadius, maxCenter + maxRadius).filter { it != fillChar }</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="longest_palindromic_substring_description">Given a string s, return the longest palindromic substring in s.</string>

    <!--Longest Substring Without Repeating Characters-->
    <string name="longest_substring_without_repeating_characters_code">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun lengthOfLongestSubstring(s: String): Int {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val charMap = HashMap&lt;Char, Int&gt;(s.length)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var max = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var start = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; s.forEachIndexed { index, char -&gt;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charMap[char]?.takeIf { it &gt;= start }?.let {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = maxOf(index - start, max)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = it + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charMap[char] = index</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return maxOf(max, s.length - start)</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="longest_substring_without_repeating_characters_description">
        Given a string s, find the length of the longest substring without repeating characters.
    </string>

    <!--Median Of Two Sorted Arrays-->
    <string name="median_of_two_sorted_arrays_code" tools:ignore="Typos">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun findMedianSortedArrays(numbers1: IntArray, numbers2: IntArray): Double {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (numbers1.size &gt; numbers2.size)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return findMedianSortedArrays(numbers2, numbers1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val mergedSize = numbers1.size + numbers2.size</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val mergedMedianIndex = (mergedSize + 1) / 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var lowerBound = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var upperBound = numbers1.size</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; while (lowerBound &lt; upperBound) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val medianIndex1 = (lowerBound + upperBound) / 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val medianIndex2 = mergedMedianIndex - medianIndex1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (numbers1[medianIndex1] &lt; numbers2[medianIndex2 - 1])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerBound = medianIndex1 + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperBound = medianIndex1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val medianIndex1 = lowerBound</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val medianIndex2 = mergedMedianIndex - medianIndex1</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val firstMedianValue = maxOf(</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex1 &lt;= 0) Int.MIN_VALUE else numbers1[medianIndex1 - 1],</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex2 &lt;= 0) Int.MIN_VALUE else numbers2[medianIndex2 - 1]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; )</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (mergedSize % 2 &gt; 0)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return firstMedianValue.toDouble()</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val secondMedianValue = minOf(</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex1 &gt;= numbers1.size) Int.MAX_VALUE else numbers1[medianIndex1],</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex2 &gt;= numbers2.size) Int.MAX_VALUE else numbers2[medianIndex2]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; )</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return (firstMedianValue + secondMedianValue).toDouble() / 2</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="median_of_two_sorted_arrays_description">
        Given two sorted arrays numbers1 and numbers2 of size m and n respectively, return the median of the two sorted arrays.
        The overall run time complexity should be O(log (m+n)).
    </string>

    <!--QuestionVO-->
    <string name="question_vo_add_two_numbers">Add Two Numbers</string>
    <string name="question_vo_longest_palindromic_substring">Longest Palindromic Substring</string>
    <string name="question_vo_longest_substring_without_repeating_characters">Longest Substring Without Repeating Characters</string>
    <string name="question_vo_median_of_two_sorted_arrays">Median Of Two Sorted Arrays</string>
    <string name="question_vo_reverse_integer">Reverse Integer</string>
    <string name="question_vo_two_sum">Two Sum</string>
    <string name="question_vo_zigzag_conversion">Zigzag Conversion</string>

    <!--Reverse Integer-->
    <string name="reverse_integer_code">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val checkPoint = 9 &nbsp;//Number of digits -1 of Int.MAX_VALUE and Int.MIN_VALUE</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var length = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var result = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var varX = x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; while (varX != 0) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val digit = varX % 10</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (++length &gt; checkPoint</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; ((result &lt; 0 &amp;&amp; result &lt; (Int.MIN_VALUE - digit) / 10)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (result &gt; 0 &amp;&amp; result &gt; (Int.MAX_VALUE - digit) / 10))</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = result * 10 + digit</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; varX /= 10</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return result</p>
]]>
    </string>
    <string name="reverse_integer_description">Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
        \nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).</string>

    <!--Sample-->
    <string name="sample_text">Sample Text</string>

    <!--Two Sum-->
    <string name="two_sum_code">
<![CDATA[
<!DOCTYPE html>
<p>&#160; &#160; fun twoSum(numbers: IntArray, target: Int): IntArray {</p>
<p>&#160; &#160; &#160; &#160; val map = HashMap&lt;Int, Int&gt;()</p>
<p>&#160; &#160; &#160; &#160; numbers.forEachIndexed{</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; index, num -&gt;</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; map[target - num]?. let {</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return intArrayOf(index, it)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; }</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; map[num] = index</p>
<p>&#160; &#160; &#160; &#160; }</p>
<p>&#160; &#160; &#160; &#160; throw IllegalStateException(&quot;No solution!&quot;)</p>
<p>&#160; &#160; }</p>
]]>
    </string>
    <string name="two_sum_description">Given an array of integers numbers and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.</string>

    <!--Zigzag Conversion-->
    <string name="zigzag_conversion_code">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun convert(s: String, numRows: Int): String {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (numRows &lt;= 1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return s</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val strBuilderArray = Array(numRows) { StringBuilder() }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; s.forEachIndexed { index, char -&gt;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val row = evaluateRow(index, numRows)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strBuilderArray[row].append(char)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;return strBuilderArray.joinToString(&quot;&quot;)</p>
<p>&nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; private fun evaluateRow(index: Int, numRows: Int): Int {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val cycle = 2 * numRows - 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val cycleIndex = index % cycle</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return if (cycleIndex / numRows == 0)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cycleIndex</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cycle - cycleIndex</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="zigzag_conversion_description">
        The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows, and then read line by line: "PAHNAPLSIIGYIR".
        Write the code that will take a string and make this conversion given a number of rows:
    </string>
</resources>