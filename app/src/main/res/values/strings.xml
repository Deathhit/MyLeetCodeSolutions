<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">My Leet Code Solutions</string>

    <!--Add Two Numbers-->
    <string name="add_two_numbers_code">
<![CDATA[
<!DOCTYPE html>
<p>&#160; &#160; fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {</p>
<p>&#160; &#160; &#160; &#160; if (l1 == null &amp;&amp; l2 == null)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; return null</p>
<p>&#160; &#160; &#160; &#160; var sum = 0</p>
<p>&#160; &#160; &#160; &#160; l1?.let { sum += l1.`val` }</p>
<p>&#160; &#160; &#160; &#160; l2?.let { sum += l2.`val` }</p>
<p>&#160; &#160; &#160; &#160; val result = ListNode(sum % 10)</p>
<p>&#160; &#160; &#160; &#160; result.next = addTwoNumbers(l1?.next, l2?.next)</p>
<p>&#160; &#160; &#160; &#160; if (sum / 10 &gt;= 1)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; result.next = addTwoNumbers(result.next, ListNode(1))</p>
<p>&#160; &#160; &#160; &#160; return result</p>
<p>&#160; &#160; }</p>
]]>
    </string>
    <string name="add_two_numbers_description">You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
    You may assume the two numbers do not contain any leading zero, except the number 0 itself.</string>
    <string name="add_two_numbers_l1_x">l1 = %s</string>
    <string name="add_two_numbers_l2_x">l2 = %s</string>
    <string name="add_two_numbers_title">Add Two Numbers</string>

    <!--Common-->
    <string name="common_input_x">Input:\n%s</string>
    <string name="common_output_x">Output:\n%s</string>
    <string name="common_run">Run</string>

    <!--Longest Substring Without Repeating Characters-->
    <string name="longest_substring_without_repeating_characters_code">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun lengthOfLongestSubstring(s: String): Int {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val charMap = HashMap&lt;Char, Int&gt;(s.length)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var max = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var start = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; s.forEachIndexed { index, char -&gt;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charMap[char]?.takeIf { it &gt;= start }?.let {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = maxOf(index - start, max)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = it + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; charMap[char] = index</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return maxOf(max, s.length - start)</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="longest_substring_without_repeating_characters_description">
        Given a string s, find the length of the longest substring without repeating characters.
    </string>
    <string name="longest_substring_without_repeating_characters_s_x">
        s = %s
    </string>

    <!--Median Of Two Sorted Arrays-->
    <string name="median_of_two_sorted_arrays_code" tools:ignore="Typos">
<![CDATA[
<!DOCTYPE html>
<p>&nbsp; &nbsp; fun findMedianSortedArrays(numbers1: IntArray, numbers2: IntArray): Double {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (numbers1.size &gt; numbers2.size)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return findMedianSortedArrays(numbers2, numbers1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val mergedSize = numbers1.size + numbers2.size</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val mergedMedianIndex = (mergedSize + 1) / 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var lowerBound = 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; var upperBound = numbers1.size</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; while (lowerBound &lt; upperBound) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val medianIndex1 = (lowerBound + upperBound) / 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val medianIndex2 = mergedMedianIndex - medianIndex1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (numbers1[medianIndex1] &lt; numbers2[medianIndex2 - 1])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowerBound = medianIndex1 + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upperBound = medianIndex1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val medianIndex1 = lowerBound</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val medianIndex2 = mergedMedianIndex - medianIndex1</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val firstMedianValue = maxOf(</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex1 &lt;= 0) Int.MIN_VALUE else numbers1[medianIndex1 - 1],</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex2 &lt;= 0) Int.MIN_VALUE else numbers2[medianIndex2 - 1]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; )</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (mergedSize % 2 &gt; 0)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return firstMedianValue.toDouble()</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; val secondMedianValue = minOf(</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex1 &gt;= numbers1.size) Int.MAX_VALUE else numbers1[medianIndex1],</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (medianIndex2 &gt;= numbers2.size) Int.MAX_VALUE else numbers2[medianIndex2]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; )</p>
<p><br></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return (firstMedianValue + secondMedianValue).toDouble() / 2</p>
<p>&nbsp; &nbsp; }</p>
]]>
    </string>
    <string name="median_of_two_sorted_arrays_description">
        Given two sorted arrays numbers1 and numbers2 of size m and n respectively, return the median of the two sorted arrays.
        The overall run time complexity should be O(log (m+n)).
    </string>
    <string name="median_of_two_sorted_arrays_numbers1_x" tools:ignore="Typos">numbers1 = %s</string>
    <string name="median_of_two_sorted_arrays_numbers2_x">numbers2 = %s</string>

    <!--QuestionVO-->
    <string name="question_vo_add_two_numbers">Add Two Numbers</string>
    <string name="question_vo_longest_substring_without_repeating_characters">Longest Substring Without Repeating Characters</string>
    <string name="question_vo_median_of_two_sorted_arrays">Median Of Two Sorted Arrays</string>
    <string name="question_vo_two_sum">Two Sum</string>

    <!--Sample-->
    <string name="sample_text">Sample Text</string>

    <!--Two Sum-->
    <string name="two_sum_code">
<![CDATA[
<!DOCTYPE html>
<p>&#160; &#160; fun twoSum(numbers: IntArray, target: Int): IntArray {</p>
<p>&#160; &#160; &#160; &#160; val map = HashMap&lt;Int, Int&gt;()</p>
<p>&#160; &#160; &#160; &#160; numbers.forEachIndexed{</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; index, num -&gt;</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; map[target - num]?. let {</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; return intArrayOf(index, it)</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; }</p>
<p>&#160; &#160; &#160; &#160; &#160; &#160; map[num] = index</p>
<p>&#160; &#160; &#160; &#160; }</p>
<p>&#160; &#160; &#160; &#160; throw IllegalStateException(&quot;No solution!&quot;)</p>
<p>&#160; &#160; }</p>
]]>
    </string>
    <string name="two_sum_description">Given an array of integers numbers and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.</string>
    <string name="two_sum_numbers_x">numbers = %s</string>
    <string name="two_sum_target_x">target = %s</string>
    <string name="two_sum_title">Two Sum</string>
</resources>